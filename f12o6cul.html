<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title></title>
    <link rel="stylesheet" href="rsc/dark.css">
    <link rel="stylesheet" href="rsc/page.css">
    <link rel="stylesheet" href="rsc/pygments.css" >
</head>
<script>
    function goto(id){
        window.location.href = "/" + id + ".html";
    }
</script>
<body>
<section id="brand" onclick="window.location.href = 'index.html'"><h1>cheat-sheet.com</h1></section>
<nav>
    <h1>rust</h1>
    <h1>:</h1>
    <h1>operators</h1>
</nav>
<main>
    <div class="code-block">
          <div class="code-header">
            <span class="language-label">rust</span>
            <button class="copy-button"><img src="../builder/rsc/copy.svg"></button>
          </div>
          <pre><code><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="c1">// arithmetic add, minus, multiply, divide</span>
<span class="mi">7</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">5</span><span class="w">              </span><span class="c1">// modulo (remainder)</span>
<span class="o">&amp;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">^</span><span class="w">              </span><span class="c1">// bitwise and, or, xor</span>
<span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w">              </span><span class="c1">// leftshift, rightshift, will crash on overflow</span>
<span class="c1">// note that in C, overflowing &lt;&lt; is actually undefined.</span>
<span class="c1">// Rust has multiple versions, each defined.</span>
<span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="p">:</span><span class="kt">u8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">0b10110011</span><span class="p">;</span><span class="w"> </span><span class="c1">// print!(&quot;{:08b}&quot;,a); // 0b10110011 padded binary output</span>
<span class="n">a</span><span class="p">.</span><span class="n">rotate_left</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">    </span><span class="c1">// 01100111 circular bit rotation, out of left -&gt; in at right</span>
<span class="n">a</span><span class="p">.</span><span class="n">wrapping_shl</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">   </span><span class="c1">// 01100110 this destroys the left-most bits that would cause overflow</span>
<span class="n">a</span><span class="p">.</span><span class="n">overflowing_shl</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="c1">// 01100110,false returns tuple (value,did it overflow the number type)</span>
<span class="n">a</span><span class="p">.</span><span class="n">rotate_right</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="w">   </span><span class="c1">// 11011001 circular bit rotation to the right</span>
<span class="o">!</span><span class="n">a</span><span class="w">                  </span><span class="c1">// 01001100 bitwise not</span>
<span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">g</span><span class="w">  </span><span class="c1">// logical comparison</span>
<span class="n">a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="n">d</span><span class="w">    </span><span class="c1">// logical boolean, and, or, not</span>

<span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">         </span><span class="c1">// pointer + dereference example</span>
<span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span><span class="w">        </span><span class="c1">// &amp;a is &#39;address of a&#39; in computers memory</span>
<span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span><span class="w">        </span><span class="c1">// *b is contents of memory at address in b (dereference)</span>
<span class="n">print</span><span class="p">(</span><span class="s">&quot;{c}&quot;</span><span class="p">);</span><span class="w">     </span><span class="c1">// 5</span>

<span class="n">overloading</span><span class="p">:</span><span class="w"> </span><span class="nc">see</span><span class="w"> </span><span class="k">struct</span>
</code></pre></div>
</main>
</body>